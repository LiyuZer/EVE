{
  "edits": [
    {
      "op": "replace",
      "line": 70,
      "count": 5,
      "text": "    # Accept epsilon only if explicitly allowed by start productions\n    if s == \"\" and \"\" in rules.get(start, []):\n        return True\n\n    # For non-empty strings, try to match productions\n    def can_derive(nt: str, remaining: str) -> bool:\n        for prod in rules.get(nt, []):\n            if prod == \"\":\n                continue  # Epsilon production\n            if remaining.startswith(prod):\n                # If production is a terminal prefix, continue with the rest\n                if not any(c.isupper() for c in prod):\n                    if can_derive(nt, remaining[len(prod):]):\n                        return True\n            elif any(c.isupper() for c in prod):\n                # Handle simple case: A -> aA or A -> a\n                term_part = \"\"\n                rest_part = \"\"\n                for i, c in enumerate(prod):\n                    if c.isupper():\n                        term_part = prod[:i]\n                        rest_part = prod[i:]\n                        break\n                else:\n                    term_part = prod\n                if remaining.startswith(term_part):\n                    new_remaining = remaining[len(term_part):]\n                    if rest_part == \"\":\n                        if new_remaining == \"\":\n                            return True\n                    elif len(rest_part) == 1 and rest_part.isupper():\n                        if can_derive(rest_part, new_remaining):\n                            return True\n        return False\n\n    return can_derive(start, s)"
    }
  ]
}