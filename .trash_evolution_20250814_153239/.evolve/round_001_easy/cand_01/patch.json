{
  "edits": [
    {
      "op": "replace",
      "line": 70,
      "count": 5,
      "text": "    # Accept epsilon only if explicitly allowed by start productions\n    if s == \"\" and \"\" in rules.get(start, []):\n        return True\n\n    # Simple recursive descent parser for non-empty strings\n    def parse(symbol: str, pos: int) -> int:\n        if pos > len(s):\n            return -1\n        if symbol.isupper():  # Nonterminal\n            for production in rules.get(symbol, []):\n                next_pos = pos\n                match = True\n                for char in production:\n                    if next_pos >= len(s) and char != \"\":\n                        match = False\n                        break\n                    if char.isupper():  # Nonterminal\n                        next_pos = parse(char, next_pos)\n                        if next_pos == -1:\n                            match = False\n                            break\n                    else:  # Terminal\n                        if next_pos < len(s) and s[next_pos] == char:\n                            next_pos += 1\n                        else:\n                            match = False\n                            break\n                if match:\n                    return next_pos\n            return -1\n        else:  # Terminal\n            if pos < len(s) and s[pos] == symbol:\n                return pos + 1\n            else:\n                return -1\n\n    # Try to parse the entire string\n    if len(s) > 0:\n        result = parse(start, 0)\n        return result == len(s)\n\n    # Everything else is rejected by the initial stub\n    return False"
    }
  ]
}