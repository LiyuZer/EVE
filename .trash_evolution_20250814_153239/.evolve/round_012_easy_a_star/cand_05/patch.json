{
  "edits": [
    {
      "op": "replace",
      "line": 67,
      "count": 5,
      "text": "    # Accept epsilon only if explicitly allowed by start productions\n    if s == \"\" and \"\" in rules.get(start, []):\n        return True\n\n    # For non-empty strings, try to match productions\n    def can_derive(nt: str, remaining: str) -> bool:\n        for production in rules.get(nt, []):\n            if _matches_production(production, remaining, rules):\n                return True\n        return False\n\n    def _matches_production(prod: str, s: str, rules: dict) -> bool:\n        # Try to match production against string\n        if not prod and not s:\n            return True\n        if not prod:\n            return False\n        if not s:\n            # Check if rest of production can derive epsilon\n            return _can_derive_epsilon(prod, rules)\n        \n        # Match first symbol\n        first_sym = prod[0]\n        rest_prod = prod[1:]\n        \n        if first_sym.isupper():\n            # Nonterminal: try all possible splits\n            for i in range(len(s) + 1):\n                prefix = s[:i]\n                suffix = s[i:]\n                if can_derive(first_sym, prefix) and _matches_production(rest_prod, suffix, rules):\n                    return True\n            return False\n        else:\n            # Terminal\n            if s[0] == first_sym:\n                return _matches_production(rest_prod, s[1:], rules)\n            else:\n                return False\n    \n    def _can_derive_epsilon(nt: str, rules: dict, visited=None) -> bool:\n        if visited is None:\n            visited = set()\n        if nt in visited:\n            return False  # Prevent infinite recursion\n        visited.add(nt)\n        \n        for production in rules.get(nt, []):\n            if not production:\n                return True\n            # Check if all symbols in production can derive epsilon\n            all_epsilon = True\n            for sym in production:\n                if sym.isupper():\n                    if not _can_derive_epsilon(sym, rules, visited.copy()):\n                        all_epsilon = False\n                        break\n                else:\n                    all_epsilon = False\n                    break\n            if all_epsilon:\n                return True\n        return False\n\n    return can_derive(start, s)"
    }
  ]
}