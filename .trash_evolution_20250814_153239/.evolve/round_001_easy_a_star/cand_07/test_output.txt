FF                                                                       [100%]
=================================== FAILURES ===================================
______________________________ test_a_star_basic _______________________________

    @pytest.mark.difficulty("easy")
    def test_a_star_basic():
        # Language: a*
        grammar = {
            "start": "S",
            "rules": {
                "S": ["aS", ""],  # S -> a S | Îµ
            },
        }
        from src.target_parser import accepts
    
        # Positive cases
>       assert accepts(grammar, "") is True
               ^^^^^^^^^^^^^^^^^^^^

tests/test_parser_easy.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/target_parser.py:76: in accepts
    start, rules = _validate_grammar(grammar)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

grammar = {'rules': {'S': ['aS', '']}, 'start': 'S'}

    def _validate_grammar(grammar: Dict) -> tuple[str, Dict[str, List[str]]]:
        if not isinstance(grammar, dict):
            raise TypeError("grammar must be a dict with keys 'start' and 'rules'")
        if "start" not in grammar or "rules" not in grammar:
            raise ValueError("grammar must contain 'start' and 'rules'")
        start = grammar["start"]
        rules = grammar["rules"]
        if not isinstance(start, str) or not start:
            raise ValueError("grammar['start'] must be a non-empty string")
        if not isinstance(rules, dict):
            raise ValueError("grammar['rules'] must be a dict")
        # Normalize rule lists
        norm_rules: Dict[str, List[str]] = {}
        for nt, prods in rules.items():
            if not isinstance(nt, str) or not nt:
                raise ValueError("Nonterminal keys must be non-empty strings")
            if not isinstance(prods, list):
                raise ValueError(f"Productions for {nt!r} must be a list of strings")
            norm_list: List[str] = []
            for p in prods:
                if not isinstance(p, str):
                    raise ValueError(f"Production for {nt!r} must be a string, got {type(p)}")
        # Accept epsilon only if explicitly allowed by start productions
>       if s == "" and "" in rules.get(start, []):
           ^
E       NameError: name 's' is not defined

src/target_parser.py:60: NameError
______________________ test_rejection_misc_short_strings _______________________

    @pytest.mark.difficulty("easy")
    def test_rejection_misc_short_strings():
        # Ensure obvious mismatches are rejected for simple grammars
        grammar = {
            "start": "S",
            "rules": {
                "S": ["aS", ""],  # a*
            },
        }
        from src.target_parser import accepts
    
        for s in ["b", "ba", "ab", "bb", "aababb"]:
>           assert accepts(grammar, s) is False
                   ^^^^^^^^^^^^^^^^^^^

tests/test_parser_easy.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/target_parser.py:76: in accepts
    start, rules = _validate_grammar(grammar)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

grammar = {'rules': {'S': ['aS', '']}, 'start': 'S'}

    def _validate_grammar(grammar: Dict) -> tuple[str, Dict[str, List[str]]]:
        if not isinstance(grammar, dict):
            raise TypeError("grammar must be a dict with keys 'start' and 'rules'")
        if "start" not in grammar or "rules" not in grammar:
            raise ValueError("grammar must contain 'start' and 'rules'")
        start = grammar["start"]
        rules = grammar["rules"]
        if not isinstance(start, str) or not start:
            raise ValueError("grammar['start'] must be a non-empty string")
        if not isinstance(rules, dict):
            raise ValueError("grammar['rules'] must be a dict")
        # Normalize rule lists
        norm_rules: Dict[str, List[str]] = {}
        for nt, prods in rules.items():
            if not isinstance(nt, str) or not nt:
                raise ValueError("Nonterminal keys must be non-empty strings")
            if not isinstance(prods, list):
                raise ValueError(f"Productions for {nt!r} must be a list of strings")
            norm_list: List[str] = []
            for p in prods:
                if not isinstance(p, str):
                    raise ValueError(f"Production for {nt!r} must be a string, got {type(p)}")
        # Accept epsilon only if explicitly allowed by start productions
>       if s == "" and "" in rules.get(start, []):
           ^
E       NameError: name 's' is not defined

src/target_parser.py:60: NameError
=========================== short test summary info ============================
FAILED tests/test_parser_easy.py::test_a_star_basic - NameError: name 's' is ...
FAILED tests/test_parser_easy.py::test_rejection_misc_short_strings - NameErr...

