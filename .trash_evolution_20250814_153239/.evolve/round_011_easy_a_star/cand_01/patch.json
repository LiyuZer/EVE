{
  "edits": [
    {
      "op": "replace",
      "line": 67,
      "count": 5,
      "text": "    # Accept epsilon only if explicitly allowed by start productions\n    if s == \"\" and \"\" in rules.get(start, []):\n        return True\n\n    # For non-empty strings, try to match productions\n    def can_derive(nt: str, pos: int) -> bool:\n        if pos == len(s):\n            return \"\" in rules.get(nt, [])\n        for prod in rules.get(nt, []):\n            if prod == \"\":\n                continue\n            # Try to match production\n            i = 0\n            while i < len(prod):\n                if prod[i].isupper():\n                    # Nonterminal: try all possible matches\n                    for j in range(pos, len(s) + 1):\n                        if can_derive(prod[i], j):\n                            # Continue with rest of production\n                            rest_pos = j\n                            rest_matched = True\n                            k = i + 1\n                            while k < len(prod):\n                                if prod[k].isupper():\n                                    # Another nonterminal\n                                    next_matched = False\n                                    for l in range(rest_pos, len(s) + 1):\n                                        if can_derive(prod[k], l):\n                                            rest_pos = l\n                                            next_matched = True\n                                            break\n                                    if not next_matched:\n                                        rest_matched = False\n                                        break\n                                else:\n                                    # Terminal\n                                    if rest_pos < len(s) and s[rest_pos] == prod[k]:\n                                        rest_pos += 1\n                                    else:\n                                        rest_matched = False\n                                        break\n                                    k += 1\n                            if rest_matched and rest_pos == len(s):\n                                return True\n                else:\n                    # Terminal\n                    if pos < len(s) and s[pos] == prod[i]:\n                        pos += 1\n                        i += 1\n                        continue\n                    else:\n                        break\n                i += 1\n        return False\n\n    return can_derive(start, 0)"
    }
  ]
}