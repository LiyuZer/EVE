{
  "edits": [
    {
      "op": "replace",
      "line": 70,
      "count": 5,
      "text": "    # Accept epsilon only if explicitly allowed by start productions\n    if s == \"\" and \"\" in rules.get(start, []):\n        return True\n\n    # For non-empty strings, try to match productions\n    def can_derive(nt: str, pos: int) -> bool:\n        if pos == len(s):\n            return \"\" in rules.get(nt, [])\n        for prod in rules.get(nt, []):\n            if prod == \"\":\n                continue\n            i = 0\n            while i < len(prod):\n                if prod[i].isupper():\n                    # Nonterminal\n                    next_pos = pos\n                    found_match = False\n                    for j in range(pos, len(s) + 1):\n                        if can_derive(prod[i], next_pos):\n                            next_pos = j\n                            found_match = True\n                            break\n                        next_pos = j\n                    if not found_match:\n                        break\n                    i += 1\n                else:\n                    # Terminal\n                    if pos >= len(s) or s[pos] != prod[i]:\n                        break\n                    pos += 1\n                    i += 1\n            else:\n                if pos == len(s):\n                    return True\n        return False\n\n    return can_derive(start, 0)"
    }
  ]
}