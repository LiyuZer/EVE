{
  "edits": [
    {
      "op": "replace",
      "line": 70,
      "count": 1,
      "text": "    # Accept epsilon only if explicitly allowed by start productions"
    },
    {
      "op": "replace",
      "line": 71,
      "count": 1,
      "text": "    if s == \"\" and \"\" in rules.get(start, []):"
    },
    {
      "op": "replace",
      "line": 72,
      "count": 1,
      "text": "        return True"
    },
    {
      "op": "replace",
      "line": 74,
      "count": 1,
      "text": "    # For non-empty strings, try to match productions"
    },
    {
      "op": "replace",
      "line": 75,
      "count": 1,
      "text": "    def can_derive(nt: str, remaining: str) -> bool:"
    },
    {
      "op": "replace",
      "line": 76,
      "count": 1,
      "text": "        if not remaining:"
    },
    {
      "op": "replace",
      "line": 77,
      "count": 1,
      "text": "            return \"\" in rules.get(nt, [])"
    },
    {
      "op": "replace",
      "line": 78,
      "count": 1,
      "text": "        for production in rules.get(nt, []):"
    },
    {
      "op": "replace",
      "line": 79,
      "count": 1,
      "text": "            if production == \"\" and not remaining:"
    },
    {
      "op": "replace",
      "line": 80,
      "count": 1,
      "text": "                return True"
    },
    {
      "op": "replace",
      "line": 81,
      "count": 1,
      "text": "            if production and production[0] == remaining[0] and len(production) == 1:"
    },
    {
      "op": "replace",
      "line": 82,
      "count": 1,
      "text": "                if len(remaining) == 1:"
    },
    {
      "op": "replace",
      "line": 83,
      "count": 1,
      "text": "                    return True"
    },
    {
      "op": "replace",
      "line": 84,
      "count": 1,
      "text": "            if production.startswith('a') and len(production) > 1:"
    },
    {
      "op": "replace",
      "line": 85,
      "count": 1,
      "text": "                if remaining.startswith('a') and can_derive(production[1], remaining[1:]):"
    },
    {
      "op": "replace",
      "line": 86,
      "count": 1,
      "text": "                    return True"
    },
    {
      "op": "replace",
      "line": 87,
      "count": 1,
      "text": "        return False"
    },
    {
      "op": "replace",
      "line": 89,
      "count": 1,
      "text": "    return can_derive(start, s)"
    }
  ]
}