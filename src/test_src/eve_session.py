from __future__ import annotations

import os
import shlex
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Tuple, Optional


SESSION_DIRNAME = ".eve"
SESSION_FILENAME = "session.sh"


def _is_valid_var(name: str) -> bool:
    if not name:
        return False
    if not (name[0].isalpha() or name[0] == "_"):
        return False
    for ch in name[1:]:
        if not (ch.isalnum() or ch == "_"):
            return False
    return True


def _repo_root_from(start: Optional[Path] = None) -> Path:
    """Find a reasonable repo root.
    - Prefer an explicitly provided start (stabilizes callers that want a fixed root)
    - Else prefer EVE_WORKSPACE_ROOT if it exists and is a dir
    - Else walk up from current file to locate a directory containing main.py
    - Else fallback to project root (src/..)
    """
    # If caller provided an explicit starting point, honor it first
    if start is not None:
        try:
            p0 = Path(start).expanduser().resolve()
        except Exception:
            p0 = Path(str(start))
        if p0.is_file():
            p0 = p0.parent
        # If this path (or one of its parents) contains main.py, use that
        cur = p0
        for _ in range(10):
            if (cur / "main.py").exists():
                return cur
            if cur.parent == cur:
                break
            cur = cur.parent
        # Otherwise, if it's a valid directory, return it directly
        if p0.exists() and p0.is_dir():
            return p0

    # Fall back to environment override only when no explicit start was provided
    env_root = os.environ.get("EVE_WORKSPACE_ROOT")
    if env_root:
        p = Path(env_root).expanduser().resolve()
        if p.exists() and p.is_dir():
            return p

    # Walk up from this file to find a directory that contains main.py
    cur = Path(__file__).resolve().absolute()
    if cur.is_file():
        cur = cur.parent
    for _ in range(10):
        if (cur / "main.py").exists():
            return cur
        if cur.parent == cur:
            break
        cur = cur.parent
    # Fallback: repo root assumed to be parent of src
    return Path(__file__).resolve().parents[1]

@dataclass
class EveSession:
    """Manage a simple, persistent shell session via a POSIX-compatible script.

    The session file lives at: <repo_root>/.eve/session.sh
    It may contain lines like:
      export VAR='value'
      unset NAME
      cd '/abs/path'

    Each command run in a fresh shell can source this file to simulate a persistent session.
    """

    repo_root: Path
    restrict_cwd_to_repo: bool = True  # reject cd outside repo by default

    def __init__(self, repo_root: Optional[Path] = None, restrict_cwd_to_repo: bool = True) -> None:
        self.repo_root = _repo_root_from(repo_root)
        self.restrict_cwd_to_repo = restrict_cwd_to_repo
        self.session_dir = self.repo_root / SESSION_DIRNAME
        self.session_file = self.session_dir / SESSION_FILENAME

    # ---------------- Filesystem helpers ----------------
    def ensure(self, reset: bool = False) -> None:
        """Ensure session directory/file exist. If reset, recreate with default cwd at repo root."""
        self.session_dir.mkdir(parents=True, exist_ok=True)
        if reset or not self.session_file.exists():
            content = self._default_content()
            self.session_file.write_text(content, encoding="utf-8")

    def reset(self) -> None:
        self.ensure(reset=True)

    def exists(self) -> bool:
        return self.session_file.exists()

    def _default_content(self) -> str:
        cd_line = f"cd {shlex.quote(str(self.repo_root))}\n"
        header = (
            "#!/usr/bin/env sh\n"
            "# Auto-generated by EveSession. Prefer using Eve to persist cd/export changes.\n"
            "# shellcheck shell=sh\n"
        )
        return header + cd_line

    def _read_lines(self) -> list[str]:
        if not self.session_file.exists():
            return []
        try:
            return self.session_file.read_text(encoding="utf-8").splitlines()
        except Exception:
            return []

    def _write_lines(self, lines: Iterable[str]) -> None:
        text = "\n".join(lines).rstrip("\n") + "\n"
        self.session_dir.mkdir(parents=True, exist_ok=True)
        self.session_file.write_text(text, encoding="utf-8")

    # ---------------- CD management ----------------
    def current_cwd(self) -> Path:
        """Return the effective cwd from the session file; fallback to repo root."""
        lines = self._read_lines()
        last_cd: Optional[Path] = None
        for ln in lines:
            s = ln.strip()
            if s.startswith("cd "):
                # naive parse: cd <path>
                arg = s[3:].strip()
                # remove surrounding quotes if present; Path resolves anyway
                if (arg.startswith("'") and arg.endswith("'")) or (arg.startswith('"') and arg.endswith('"')):
                    arg = arg[1:-1]
                try:
                    p = Path(arg).expanduser().resolve()
                    last_cd = p
                except Exception:
                    pass
        return last_cd or self.repo_root

    def update_cd(self, target: str | Path) -> Tuple[bool, str]:
        """Persist a cd target.
        Returns (ok, message). If restrict_cwd_to_repo and target is outside, reject.
        """
        base = self.current_cwd()
        p = Path(str(target)).expanduser()
        try:
            new = (base / p).resolve() if not p.is_absolute() else p.resolve()
        except Exception:
            return False, f"cd: invalid path: {target}"
        if not new.exists() or not new.is_dir():
            return False, f"cd: no such directory: {target}"
        if self.restrict_cwd_to_repo:
            try:
                new.relative_to(self.repo_root)
            except Exception:
                return False, f"cd: outside workspace not allowed: {new}"
        # rewrite session: drop prior cd lines; append new one at end to ensure precedence
        lines = [ln for ln in self._read_lines() if not ln.strip().startswith("cd ")]
        lines.append(f"cd {shlex.quote(str(new))}")
        self._write_lines(lines)
        return True, f"[cwd set to] {new}"

    # ---------------- Env management ----------------
    def export(self, name: str, value: str) -> Tuple[bool, str]:
        if not _is_valid_var(name):
            return False, f"export: invalid name: {name}"
        # remove any prior lines for this name
        prefix_export = f"export {name}="
        prefix_unset = f"unset {name}"
        new_lines = []
        for ln in self._read_lines():
            s = ln.strip()
            if s.startswith(prefix_export) or s == prefix_unset:
                continue
            new_lines.append(ln)
        quoted = shlex.quote(value)
        new_lines.append(f"export {name}={quoted}")
        self._write_lines(new_lines)
        return True, f"[export set] {name}"

    def unset(self, name: str) -> Tuple[bool, str]:
        if not _is_valid_var(name):
            return False, f"unset: invalid name: {name}"
        prefix_export = f"export {name}="
        prefix_unset = f"unset {name}"
        new_lines = []
        for ln in self._read_lines():
            s = ln.strip()
            if s.startswith(prefix_export) or s == prefix_unset:
                continue
            new_lines.append(ln)
        new_lines.append(prefix_unset)
        self._write_lines(new_lines)
        return True, f"[export unset] {name}"

    # ---------------- Venv helpers ----------------
    def current_venv(self) -> Optional[Path]:
        """Return current VIRTUAL_ENV path from session if set."""
        for ln in self._read_lines()[::-1]:
            s = ln.strip()
            if s.startswith("export VIRTUAL_ENV="):
                val = s[len("export VIRTUAL_ENV="):].strip()
                # strip surrounding quotes
                if (val.startswith("'") and val.endswith("'")) or (val.startswith('"') and val.endswith('"')):
                    val = val[1:-1]
                try:
                    p = Path(val).expanduser().resolve()
                    return p
                except Exception:
                    return None
        return None

    def activate_venv(self, venv_path: str | Path) -> Tuple[bool, str]:
        """Persist virtualenv activation by exporting VIRTUAL_ENV and prepending its bin/Scripts to PATH."""
        base = self.current_cwd()
        in_path = Path(str(venv_path)).expanduser()
        try:
            venv_abs = (base / in_path).resolve() if not in_path.is_absolute() else in_path.resolve()
        except Exception:
            return False, f"venv: invalid path: {venv_path}"
        # Validate expected executables
        bin_dir = venv_abs / "bin"
        scripts_dir = venv_abs / "Scripts"
        has_bin = (bin_dir / "python").exists() or (bin_dir / "python3").exists()
        has_scripts = (scripts_dir / "python.exe").exists() or (scripts_dir / "python").exists()
        if not (has_bin or has_scripts):
            return False, f"venv: not a virtualenv: {venv_abs}"
        # Rewrite lines: remove prior VIRTUAL_ENV lines and PATH lines that reference $VIRTUAL_ENV
        new_lines: list[str] = []
        for ln in self._read_lines():
            s = ln.strip()
            if s.startswith("export VIRTUAL_ENV=") or s == "unset VIRTUAL_ENV":
                continue
            if s.startswith("export PATH=") and "$VIRTUAL_ENV" in s:
                continue
            new_lines.append(ln)
        # Append new exports
        new_lines.append(f"export VIRTUAL_ENV={shlex.quote(str(venv_abs))}")
        new_lines.append("export PATH=\"$VIRTUAL_ENV/bin:$PATH\"")
        self._write_lines(new_lines)
        return True, f"[venv activated] {venv_abs}"

    def deactivate_venv(self) -> Tuple[bool, str]:
        """Remove VIRTUAL_ENV and PATH modifications referencing it."""
        new_lines: list[str] = []
        for ln in self._read_lines():
            s = ln.strip()
            if s.startswith("export VIRTUAL_ENV=") or s == "unset VIRTUAL_ENV":
                continue
            if s.startswith("export PATH=") and "$VIRTUAL_ENV" in s:
                continue
            new_lines.append(ln)
        self._write_lines(new_lines)
        return True, "[venv deactivated]"

    # ---------------- Composition helpers ----------------
    def source_command(self) -> str:
        """Return a POSIX-sh snippet that safely sources the session file if present."""
        # Use absolute path to avoid reliance on process cwd
        path = shlex.quote(str(self.session_file))
        return f"[ -f {path} ] && . {path} || true"

    def compose_prefixed(self, command: str) -> str:
        """Return a shell command that sources the session then runs the given command.
        Note: caller is responsible for choosing the shell. This snippet is POSIX-sh compatible.
        """
        # Avoid double-quoting by shlex-quoting the payload when embedding into sh -c
        src = self.source_command()
        return f"{src}; {command}"


__all__ = [
    "EveSession",
    "_repo_root_from",
]